
#include <string.h>
#include "uart23xx.h"
#include "xprintf.h"
#include "interrupt.h"
#define DEBUG1
#define LED1 0
#define LED2 1
// UART interrupt
// U0IIR register
#define IIR_RLS         0x03
#define IIR_RDA         0x02
#define IIR_CTI         0x06
#define IIR_THRE        0x01

// U0LSR register
#define LSR_RDR         0x01
#define LSR_OE          0x02
#define LSR_PE          0x04
#define LSR_FE          0x08
#define LSR_BI          0x10
#define LSR_THRE        0x20
#define LSR_TEMT        0x40
#define LSR_RXFE        0x80

#define BUFSIZE         16
#define MESSAGE_LENGTH  8

//UART
// bit PCONP register
#define PCUART0         3

// bit PCLKSEL0 register
#define PINSEL_UART0_0  6         
#define PINSEL_UART0_1  7 

// bit U0LCR register
#define word_len_0      0
#define word_len_1      1
#define DLAB            7

//bit U0FCR register
#define FIFO_Enable     0
#define RX_FIFO_Reset   1
#define TX_FIFO_Reset   2

//bit U0IER register
#define RBR_Enable      0
#define THRE_Enable     1
#define RLS_Enable      2

//UART message
#define DeviceID        0xAA

#define STATUS_OK       1
#define STATUS_DATA     2
#define STATUS_RTR      3

#define STATUS_ERROR    -1
#define STATUS_FULL     -2
#define STATUS_EMPTY    -3                                                             
#define STATUS_BUSY     -4
/*---------------------------------------------------------*/
/* 1000Hz timer interrupt generated by TIMER0              */
/*---------------------------------------------------------*/
//UART0
//unsigned short UART0Status;
unsigned char UART0Count = 0;
unsigned char UART0TxEmpty = 1;
unsigned char UART0Buffer[BUFSIZE];
unsigned char UART0Str[MESSAGE_LENGTH];
unsigned char UART_TxStr[MESSAGE_LENGTH];

unsigned char RxMessage_Dev_ID;
unsigned char RxMessage_Command;
unsigned short RxMessage_Addr;
unsigned short RxMessage_Data;
unsigned short RxMessage_CRC;

unsigned char TxMessage_Dev_ID = DeviceID;
unsigned char TxMessage_Command = 0x19;
unsigned short TxMessage_Addr = 0xFAFA;
unsigned short TxMessage_Data = 0xCCBB;
unsigned short TxMessage_CRC = 0xD199;

unsigned char RxCount,Index;
void Isr_TIMER0 (void)
{
	T0IR = 1;			/* Clear irq flag */

	/* Timer++;			[> Performance timer <] */
	/* TmrFrm += 1000;		[> Video frame timer (disp.c) <] */

	/* MCI_timerproc();	[> Disk timer process <] */

} 

void GPIOInit (void)
{
	/* FIO2MASK = 0; */
	/* Leds to output */
	FIO2DIR0 |= (1 << LED1) | (1 << LED2);
	/* Switch on leds */
	FIO2SET0 = (1 << LED1) | (1 << LED2);
	SCS |= 1;
}
void UARTSend(unsigned char *BufferPtr, unsigned short Length )
{
  U0IER &= ~(1 << RBR_Enable );     // Disable RBR
  
  while ( Length != 0 )
  {
    // THRE status, contain valid data 
    while (U0LSR & (1 << 5) ==0 );//ждём пока освободиться регистр THR
    UART0TxEmpty = 0;
    U0THR = *BufferPtr;// в сдвиговый регистр положить данные
     
    BufferPtr++;
    Length--;
  }
  
  UART0Count = 0;
  U0IER |= (1 << RBR_Enable );      // Re-enable RBR 
  
  return;
}

void InitUART0(void)
{
  //UART0
  PCONP |= 1 << PCUART0; // Питание на UART0
  //PCLKSEL0 |= 1 << PINSEL_UART0_0;      // PCLK = CCLK
  
  //8 bit lenght word,1 stop bit,disable parity generation,disable breake transmission, enable access to Divisor Latches
  U0LCR |= (1 << word_len_0)|(1 << word_len_1)|(1 << DLAB);
  //f = 18 mGz,Baud = 115200.
  U0FDR = 0xC1;
  U0DLL = 0x09;
  U0DLM = 0x00;
  U0LCR &= ~(1 << DLAB);//DLAB = 0
  
  //UART FIFO Нужно ли оно?
  U0FCR |= ((1 << FIFO_Enable )|(1 << RX_FIFO_Reset)|(1 << TX_FIFO_Reset));//Enable and reset TX and RX FIFO
  
  //Настройка ножек мк: P0(2) - TxD,P0(3) - RxD.
  //P0.02,P0.03 - pull-up mode
  PINSEL0 |= (1 << 4)|(1 << 6);
  
  //Interrupts
  /* InstallIRQ( UART0_INT, (void *)UART0_INT_Handler, 0x0E); */
  U0IER |= ((1 << RBR_Enable )|(1 << THRE_Enable)|(1 << RLS_Enable));/* Enable UART0 interrupt */
  
}
void IoInit1(void)
{
// 1. Init OSC
	SCS = (1 << 5);
	/* SCS_bit.OSCRANGE = 0; */
	/* SCS_bit.OSCEN = 1; */
	// 2.  Wait for OSC ready
	/* while(!SCS_bit.OSCSTAT); */
  while (!(SCS & 0x40)); //	[>Osc stabilization procedure<] 
	// 3. Disconnect PLL
	PLLCON = 1; 
	/* PLLCON_bit.PLLC = 0; */
	PLLFEED = 0xAA;
	PLLFEED = 0x55;
	// 4. Disable PLL
	PLLCON = 0;
	PLLFEED = 0xAA;
	PLLFEED = 0x55;
	// 5. Select source clock for PLL
	CLKSRCSEL = 1;			/* Select external as the PLL clock source */
	/* CLKSRCSEL_bit.CLKSRC = 1; // Selects the main oscillator as a PLL clock source. */
	// 6. Set PLL settings 288 MHz
	PLLCFG = ((2 - 1) << 16) | (24 - 1);	/* Re-configure PLL */
	/* PLLCFG_bit.MSEL = 24-1; */
	/* PLLCFG_bit.NSEL = 2-1; */
	PLLFEED = 0xAA;
	PLLFEED = 0x55;
	// 7. Enable PLL
	/* PLLCON_bit.PLLE = 1; */
	PLLCON |= 1 << 0; 
	PLLFEED = 0xAA;
	PLLFEED = 0x55;
	// 8. Wait for the PLL to achieve lock
	/* while(!PLLSTAT_bit.PLOCK); */
	while ((PLLSTAT & (1 << 26)) == 0);	/* Wait for PLL locked */
	// 9. Set clk divider settings
	CCLKCFG   = 4-1;            // 1/4 Fpll - 72 MHz; 1/5 - 60
	//USBCLKCFG = 6-1;            // 1/6 Fpll - 48 MHz
	PCLKSEL0 = PCLKSEL1 = 0;    // other peripherals


	PCLKSEL1 = 1 << 2;	//GPIO: 0 - 1/4; 1 - 1; 2 - 1/2; 3 - 1/8
	/* PCLKSEL0_bit.PCLK_TIMER0 = 1;	//0 - 1/4; 1 - 1; 2 - 1/2; 3 - 1/8 */
	/* PCLKSEL0_bit.PCLK_UART0 = 0;	//UART0: 0 - 1/4; 1 - 1; 2 - 1/2; 3 - 1/8 */
        
	// 10. Connect the PLL
	PLLCON |= 1 << 1;
	PLLFEED = 0xAA;
	PLLFEED = 0x55;

}
static
void IoInit (void)
{
#define PLL_N		2UL
#define PLL_M		72UL
#define CCLK_DIV	4

	if ( PLLSTAT & (1 << 25) ) {
		PLLCON = 1;				/* Disconnect PLL output if PLL is in use */
		PLLFEED = 0xAA; PLLFEED = 0x55;
	}
	PLLCON = 0;				/* Disable PLL */
	PLLFEED = 0xAA; PLLFEED = 0x55;
/* SCS |= (1<<4); 	[> Set ext oscillator range <]
 * SCS |= (1<<5); [> External osc enable <]
 * while (!(SCS & 0x40)); 	[>Osc stabilization procedure<] */
	CLKSRCSEL = 0;			/* Select external as the PLL clock source */

	PLLCFG = ((PLL_N - 1) << 16) | (PLL_M - 1);	/* Re-configure PLL */
	PLLFEED = 0xAA; PLLFEED = 0x55;
	PLLCON = 1;				/* Enable PLL */
	PLLFEED = 0xAA; PLLFEED = 0x55;

	while ((PLLSTAT & (1 << 26)) == 0);	/* Wait for PLL locked */

	CCLKCFG = CCLK_DIV-1;	/* Select CCLK frequency (divide ratio of hclk) */
	PLLCON = 3;				/* Connect PLL output to the sysclk */
	PLLFEED = 0xAA; PLLFEED = 0x55;

	MAMCR = 0;				/* Configure MAM with 0 wait operation */
	MAMTIM = 3;
	MAMCR = 2;

	PCLKSEL0 = 0x00000000;	/* Initialize peripheral clock to default */
	PCLKSEL1 = 0x00000000;

	ClearVector();			/* Initialie VIC */
	GPIOInit();
	SCS |= 1;				/* Enable FIO0 and FIO1 */

	/* Initialize Timer0 as 1kHz interval timer */
	RegisterIrq(TIMER0_IRQn, Isr_TIMER0, PRI_LOWEST);
	T0CTCR = 0;
	T0MR0 = 18000 - 1;		/* 18M / 1k = 18000 */
	T0MCR = 0x3;			/* Clear TC and Interrupt on MR0 match */
	T0TCR = 1;

	IrqEnable();			/* Enable Irq */
}



int main (void)
{
	
	GPIOInit();
	IoInit1();	//			[> Initialize PLL, VIC and timer <]
	InitUART0();
	/* uart0_init();			[> Initialize UART and join it to the console <] */
	UARTSend("LPC initialized\n", 16);
	/* spi_init(); */
	/* xputs("\nLPC initialized\n"); */
	/* xdev_in(uart0_getc); */
	/* xdev_out(uart0_putc); */
	
	while(1);
	return 0;
}

